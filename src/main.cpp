// main.cpp
#include <iostream>
#include <sstream> // 用於字串解析
#include <limits>  // 用於 std::numeric_limits
#include <thread>
#include <chrono>
#include <random>
#include <vector>
#include <algorithm>
#include <ctime>
#include <cstdlib>
#include <iomanip>
#include <string>
#include <atomic>

#include "battleManager.h"
#include "playerManager.h"
#include "scheduleManager.h"
#include "dbManager.h"
#include "../utils/utils.h"

std::atomic<bool> isRunning = true; // 控制命令處理執行緒的運行狀態

void commandThread();
void listAllPlayers();
void simulatePlayers(uint32_t counts);
void exitGame();

int main()
{
    std::srand(static_cast<unsigned int>(std::time(nullptr)));

    std::cout << "--- Game Match Demo Starting (Multithreaded Server) ---\n";

    // 1. 初始化所有核心管理器
    if (!DbManager::instance().initialize())
    {
        std::cerr << "Error: Failed to initialize DbManager!\n";
        return 1;
    }

    if (!PlayerManager::instance().initialize())
    {
        std::cerr << "Error: Failed to initialize PlayerManager!\n";
        return 1;
    }

    if (!BattleManager::instance().initialize())
    {
        std::cerr << "Error: Failed to initialize BattleManager!\n";
        return 1;
    }

    if (!ScheduleManager::instance().initialize())
    {
        std::cerr << "Error: Failed to initialize ScheduleManager!\n";
        return 1;
    }

    // 確保資料庫結構和加載資料
    DbManager::instance().ensureTableSchema();
    DbManager::instance().loadTableData();

    std::cout << "Game Server initialized. Main thread ready for commands.\n";
    std::cout << "Type 'quit' or 'exit' to shut down the server.\n";

    std::thread cmdThread(commandThread);   // 啟動主控台命令處理執行緒

    // main 函式現在會等待 cmdThread 結束。
    // 這意味著只要 cmdThread 沒結束，main 函式就會保持活躍，整個程式也會運行。
    // 當你在 commandThread 中輸入 "exit" 時，isRunning 會變為 false，cmdThread 結束，
    // 之後 main 函式將繼續執行清理代碼。
    cmdThread.join();

    std::cout << "--- Game Match Demo Shutting Down ---\n";

    // *** 注意!所有管理器的 release() 呼叫都在 exitGame() 函式中統一處理 ***

    return 0;
}

// 模擬玩家登入並匹配
void simulatePlayers(uint32_t counts)
{
    std::cout << "--- Starting player simulation batch ---\n";

    std::vector<uint64_t> vecLoggedInIds;

    // 獲取所有玩家ob
    auto pMapAllPlayers = PlayerManager::instance().getAllPlayers();
    // 獲取在線玩家id
    std::set<uint64_t>* pSetOnlinePlayerIds = PlayerManager::instance().getOnlinePlayerIds();

    // 實作隨機取得一個不在線的玩家id
    uint64_t maxId = static_cast<uint64_t>(pMapAllPlayers->size());
    for (uint32_t i = 0; i < counts; i++)
    {
        // 取得一個隨機(1~maxID)
        uint64_t playerId = random_utils::getRandom(maxId);
        auto itRes = pSetOnlinePlayerIds->find(playerId);
        if (itRes != pSetOnlinePlayerIds->end())
        {
            playerId = 0;
        }

        Player* pPlayer = PlayerManager::instance().playerLogin(playerId);
        if (pPlayer != nullptr)
        {
            playerId = pPlayer->getId(); // 假設 playerLogin 會返回有效的玩家 ID
            vecLoggedInIds.push_back(playerId);
            // 將玩家加入匹配隊列
            BattleManager::instance().addPlayerToQueue(pPlayer);
        }
        else
        {
            std::cerr << "Error: Failed to login player " << playerId << "\n";
        }
    }

    std::cout << "Waiting 5 seconds for players to potentially match...\n";
    // 等待一段時間，讓玩家有機會匹配和戰鬥
    std::this_thread::sleep_for(std::chrono::seconds(5));

    // // 如果需要，可以使這些玩家登出
    // for (uint64_t id : vecLoggedInIds)
    // {
    //     if (PlayerManager::instance().playerLogout(id))
    //     {
    //         std::cout << "Player " << id << " logged out.\n";
    //     }
    //     else
    //     {
    //         std::cerr << "Error: Failed to logout player " << id << "\n";
    //     }
    // }

    std::cout << "--- Player simulation batch finished ---\n";
}
// 命令處理執行緒的函式
void commandThread()
{
    std::cout << "Command thread started. Available commands: <list [ID|all]>, <query ID>, <start [count]>, <exit>\n";

    std::string line_input; // 用於讀取整行輸入
    while (isRunning)
    {
        // ***** 關鍵修正：移除或註銷掉這些行 *****
        // std::cin.clear(); // 移除這行，因為 getline 不會設置錯誤狀態
        // std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // 移除這行，因為 getline 已經移除了換行符
        // ***************************************

        std::cout << "> "; // 提示用戶輸入
        std::getline(std::cin, line_input); // 阻塞式讀取一行輸入。它會讀取直到換行符，並把換行符移除。

        // 檢查是否讀取成功（避免在 EOF 或錯誤狀態下繼續處理）
        if (std::cin.fail() || std::cin.eof()) {
            std::cout << "Input stream error or end of file detected. Exiting command thread.\n";
            exitGame(); // 或者其他適當的錯誤處理
            break;
        }

        std::istringstream iss(line_input);
        std::string command_name;
        iss >> command_name;

        if (command_name.empty()) {
            continue; // 處理空行
        }

        std::transform(command_name.begin(), command_name.end(), command_name.begin(), ::tolower);

        if (command_name == "list")
        {
            listAllPlayers();
        }
        else if (command_name == "query")
        {
            std::string arg;
            if (!(iss >> arg))
            {
                std::cout << "Usage: query <player_id>\n";
                continue;
            }

            try {
                uint64_t playerId = std::stoull(arg);
                uint32_t score = 0;
                uint32_t wins = 0;
                uint64_t updatedTime = 0;

                if (DbManager::instance().queryPlayerBattles(playerId, score, wins, updatedTime))
                {
                    std::cout << "\n----- Player Data (ID: " << playerId << ") -----\n";
                    std::cout << std::left << std::setw(10) << "Score"
                        << std::setw(10) << "Wins"
                        << std::setw(25) << "Updated Time" << "\n";
                    std::cout << "---------------------------------------------------\n";
                    std::cout << std::left << std::setw(10) << score
                        << std::setw(10) << wins
                        << std::setw(25) << time_utils::formatTimestampMs(updatedTime) << "\n";
                    std::cout << "---------------------------------------------------\n";
                }
                else
                {
                    std::cout << "Player ID " << arg << " not found or no data.\n";
                }
            }
            catch (const std::invalid_argument&) {
                std::cout << "Invalid player ID format: '" << arg << "'. Please enter a valid number.\n";
            }
            catch (const std::out_of_range&) {
                std::cout << "Player ID '" << arg << "' is out of range.\n";
            }
        }
        else if (command_name == "start")
        {
            int count = 1;
            std::string arg;
            if (iss >> arg)
            {
                try {
                    count = std::stoi(arg);
                    if (count <= 0) {
                        std::cout << "Count must be a positive number.\n";
                        continue;
                    }
                }
                catch (const std::invalid_argument&) {
                    std::cout << "Invalid count format: '" << arg << "'. Using default (1).\n";
                    count = 1;
                }
                catch (const std::out_of_range&) {
                    std::cout << "Count '" << arg << "' is out of range. Using default (1).\n";
                    count = 1;
                }
            }
            simulatePlayers(count);
        }
        else if (command_name == "exit" || command_name == "quit")
        {
            exitGame();
        }
        else
        {
            std::cout << "Unknown command '" << line_input << "'. Available commands: <list [ID|all]>, <query ID>, <start [count]>, <exit>\n";
        }
    }

    std::cout << "Command thread ended.\n";
}
//
//void commandThread()
//{
//    std::cout << "Command thread started. Available commands: <list>, <start>, <exit>\n";
//
//    std::string command; // 直接讀取命令字串
//    while (isRunning)
//    {
//        // 確保在每次等待使用者輸入前，清除可能的緩衝區殘留
//        // 這是處理 `std::cin` 怪異行為的關鍵步驟，即使在簡單模式下也建議保留。
//        //std::cin.clear();
//        //std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
//
//        std::cout << "> "; // 提示用戶輸入
//        std::getline(std::cin, command); // 阻塞式讀取一行輸入
//
//        // 將命令名稱轉換為小寫，以便不區分大小寫
//        //std::transform(command.begin(), command.end(), command.begin(), ::tolower);
//
//        if (command == "list")
//        {
//            listAllPlayers();
//        }
//        else if (command == "start") // 模擬玩家活動的命令
//        {
//            simulatePlayers(10); // 總是模擬一次單個玩家
//        }
//        else if (command == "exit" || command == "quit") // 退出命令
//        {
//            exitGame(); // 呼叫 exitGame 會設定 isRunning = false
//        }
//        else if (command.empty()) // 處理空行 (只有 Enter)
//        {
//            // 什麼都不做，只是等待下一次輸入
//        }
//        else // 未知命令
//        {
//            std::cout << "Unknown command '" << command << "'. Available commands: <list>, <start>, <exit>\n";
//        }
//    }
//
//    std::cout << "Command thread ended.\n";
//}
// 列出所有玩家資訊
void listAllPlayers()
{
    auto pMapPlayers = PlayerManager::instance().getAllPlayers();
    if (pMapPlayers->empty())
    {
        std::cout << "No players currently.\n";
        return;
    }

    std::cout << "\n----- PLAYERS LIST -----\n";
    std::cout << std::left << std::setw(10) << "ID"
        << std::setw(10) << "Score"
        << std::setw(10) << "Level" // 假設 Player::getTier() 對應 Level
        << std::setw(10) << "Wins"
        << std::setw(25) << "Updated Time" << "\n"; // 新增 Updated Time 欄位
    std::cout << "--------------------------------------------------------\n"; // 調整分隔線長度

    for (const auto& itPlayer : *pMapPlayers)
    {
        Player* pPlayer = itPlayer.second.get();
        if (pPlayer == nullptr)
        {
            continue;
        }
        std::cout << std::left << std::setw(10) << pPlayer->getId()
            << std::setw(10) << pPlayer->getScore()
            << std::setw(10) << pPlayer->getTier()
            << std::setw(10) << pPlayer->getWins();

        // 呼叫 Player 的 getUpdatedTimestamp() 並格式化
        std::cout << std::setw(25) << time_utils::formatTimestampMs(pPlayer->getUpdatedTime()) << "\n";
    }

    std::cout << "--------------------------------------------------------\n"; // 調整分隔線長度
}

// 退出遊戲，執行清理操作
void exitGame()
{
    isRunning = false; // 設定旗標，指示 commandThread 結束迴圈
    std::cout << "Exiting game...\n";

    // 確保所有管理器的 release() 函式被呼叫，並按照正確的順序釋放資源。
    // 通常依賴其他組件的先釋放，或者確保執行緒相關的組件先安全停止。
    // ScheduleManager.release() 會等待其內部執行緒結束。
    ScheduleManager::instance().release(); // 最重要的，確保後台排程執行緒安全關閉
    BattleManager::instance().release();   // 釋放戰鬥管理器資源
    PlayerManager::instance().release();   // 釋放玩家管理器資源
    DbManager::instance().release();       // 釋放資料庫管理器資源

    // 這裡可以添加任何其他需要的清理代碼
}